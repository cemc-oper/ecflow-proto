// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ecflow_client.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ecflow_5fclient_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ecflow_5fclient_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ecflow_5fclient_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ecflow_5fclient_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ecflow_5fclient_2eproto;
namespace ecflow_client {
class NodeRequest;
class NodeRequestDefaultTypeInternal;
extern NodeRequestDefaultTypeInternal _NodeRequest_default_instance_;
class NodeResponse;
class NodeResponseDefaultTypeInternal;
extern NodeResponseDefaultTypeInternal _NodeResponse_default_instance_;
class ResponseStatus;
class ResponseStatusDefaultTypeInternal;
extern ResponseStatusDefaultTypeInternal _ResponseStatus_default_instance_;
class StatusRecordsResponse;
class StatusRecordsResponseDefaultTypeInternal;
extern StatusRecordsResponseDefaultTypeInternal _StatusRecordsResponse_default_instance_;
class StatusRecordsResponse_StatusMapEntry_DoNotUse;
class StatusRecordsResponse_StatusMapEntry_DoNotUseDefaultTypeInternal;
extern StatusRecordsResponse_StatusMapEntry_DoNotUseDefaultTypeInternal _StatusRecordsResponse_StatusMapEntry_DoNotUse_default_instance_;
class StatusRequest;
class StatusRequestDefaultTypeInternal;
extern StatusRequestDefaultTypeInternal _StatusRequest_default_instance_;
class StatusResponse;
class StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
}  // namespace ecflow_client
PROTOBUF_NAMESPACE_OPEN
template<> ::ecflow_client::NodeRequest* Arena::CreateMaybeMessage<::ecflow_client::NodeRequest>(Arena*);
template<> ::ecflow_client::NodeResponse* Arena::CreateMaybeMessage<::ecflow_client::NodeResponse>(Arena*);
template<> ::ecflow_client::ResponseStatus* Arena::CreateMaybeMessage<::ecflow_client::ResponseStatus>(Arena*);
template<> ::ecflow_client::StatusRecordsResponse* Arena::CreateMaybeMessage<::ecflow_client::StatusRecordsResponse>(Arena*);
template<> ::ecflow_client::StatusRecordsResponse_StatusMapEntry_DoNotUse* Arena::CreateMaybeMessage<::ecflow_client::StatusRecordsResponse_StatusMapEntry_DoNotUse>(Arena*);
template<> ::ecflow_client::StatusRequest* Arena::CreateMaybeMessage<::ecflow_client::StatusRequest>(Arena*);
template<> ::ecflow_client::StatusResponse* Arena::CreateMaybeMessage<::ecflow_client::StatusResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ecflow_client {

// ===================================================================

class ResponseStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecflow_client.ResponseStatus) */ {
 public:
  ResponseStatus();
  virtual ~ResponseStatus();

  ResponseStatus(const ResponseStatus& from);
  ResponseStatus(ResponseStatus&& from) noexcept
    : ResponseStatus() {
    *this = ::std::move(from);
  }

  inline ResponseStatus& operator=(const ResponseStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseStatus& operator=(ResponseStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseStatus* internal_default_instance() {
    return reinterpret_cast<const ResponseStatus*>(
               &_ResponseStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ResponseStatus& a, ResponseStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseStatus* New() const final {
    return CreateMaybeMessage<ResponseStatus>(nullptr);
  }

  ResponseStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseStatus& from);
  void MergeFrom(const ResponseStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecflow_client.ResponseStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ecflow_5fclient_2eproto);
    return ::descriptor_table_ecflow_5fclient_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorStringFieldNumber = 2,
    kHasErrorFieldNumber = 1,
  };
  // string error_string = 2;
  void clear_error_string();
  const std::string& error_string() const;
  void set_error_string(const std::string& value);
  void set_error_string(std::string&& value);
  void set_error_string(const char* value);
  void set_error_string(const char* value, size_t size);
  std::string* mutable_error_string();
  std::string* release_error_string();
  void set_allocated_error_string(std::string* error_string);
  private:
  const std::string& _internal_error_string() const;
  void _internal_set_error_string(const std::string& value);
  std::string* _internal_mutable_error_string();
  public:

  // bool has_error = 1;
  void clear_has_error();
  bool has_error() const;
  void set_has_error(bool value);
  private:
  bool _internal_has_error() const;
  void _internal_set_has_error(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ecflow_client.ResponseStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_string_;
  bool has_error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecflow_5fclient_2eproto;
};
// -------------------------------------------------------------------

class StatusRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecflow_client.StatusRequest) */ {
 public:
  StatusRequest();
  virtual ~StatusRequest();

  StatusRequest(const StatusRequest& from);
  StatusRequest(StatusRequest&& from) noexcept
    : StatusRequest() {
    *this = ::std::move(from);
  }

  inline StatusRequest& operator=(const StatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusRequest& operator=(StatusRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusRequest* internal_default_instance() {
    return reinterpret_cast<const StatusRequest*>(
               &_StatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StatusRequest& a, StatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusRequest* New() const final {
    return CreateMaybeMessage<StatusRequest>(nullptr);
  }

  StatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusRequest& from);
  void MergeFrom(const StatusRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecflow_client.StatusRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ecflow_5fclient_2eproto);
    return ::descriptor_table_ecflow_5fclient_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerFieldNumber = 1,
    kRepoFieldNumber = 2,
    kHostFieldNumber = 3,
    kPortFieldNumber = 4,
  };
  // string owner = 1;
  void clear_owner();
  const std::string& owner() const;
  void set_owner(const std::string& value);
  void set_owner(std::string&& value);
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  std::string* mutable_owner();
  std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // string repo = 2;
  void clear_repo();
  const std::string& repo() const;
  void set_repo(const std::string& value);
  void set_repo(std::string&& value);
  void set_repo(const char* value);
  void set_repo(const char* value, size_t size);
  std::string* mutable_repo();
  std::string* release_repo();
  void set_allocated_repo(std::string* repo);
  private:
  const std::string& _internal_repo() const;
  void _internal_set_repo(const std::string& value);
  std::string* _internal_mutable_repo();
  public:

  // string host = 3;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string port = 4;
  void clear_port();
  const std::string& port() const;
  void set_port(const std::string& value);
  void set_port(std::string&& value);
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  std::string* mutable_port();
  std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // @@protoc_insertion_point(class_scope:ecflow_client.StatusRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr repo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecflow_5fclient_2eproto;
};
// -------------------------------------------------------------------

class StatusRecordsResponse_StatusMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StatusRecordsResponse_StatusMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StatusRecordsResponse_StatusMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  StatusRecordsResponse_StatusMapEntry_DoNotUse();
  StatusRecordsResponse_StatusMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StatusRecordsResponse_StatusMapEntry_DoNotUse& other);
  static const StatusRecordsResponse_StatusMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StatusRecordsResponse_StatusMapEntry_DoNotUse*>(&_StatusRecordsResponse_StatusMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ecflow_client.StatusRecordsResponse.StatusMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ecflow_client.StatusRecordsResponse.StatusMapEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ecflow_5fclient_2eproto);
    return ::descriptor_table_ecflow_5fclient_2eproto.file_level_metadata[2];
  }

  public:
};

// -------------------------------------------------------------------

class StatusRecordsResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecflow_client.StatusRecordsResponse) */ {
 public:
  StatusRecordsResponse();
  virtual ~StatusRecordsResponse();

  StatusRecordsResponse(const StatusRecordsResponse& from);
  StatusRecordsResponse(StatusRecordsResponse&& from) noexcept
    : StatusRecordsResponse() {
    *this = ::std::move(from);
  }

  inline StatusRecordsResponse& operator=(const StatusRecordsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusRecordsResponse& operator=(StatusRecordsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusRecordsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusRecordsResponse* internal_default_instance() {
    return reinterpret_cast<const StatusRecordsResponse*>(
               &_StatusRecordsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StatusRecordsResponse& a, StatusRecordsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusRecordsResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusRecordsResponse* New() const final {
    return CreateMaybeMessage<StatusRecordsResponse>(nullptr);
  }

  StatusRecordsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusRecordsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusRecordsResponse& from);
  void MergeFrom(const StatusRecordsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusRecordsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecflow_client.StatusRecordsResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ecflow_5fclient_2eproto);
    return ::descriptor_table_ecflow_5fclient_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStatusMapFieldNumber = 4,
    kOwnerFieldNumber = 1,
    kRepoFieldNumber = 2,
    kResponseStatusFieldNumber = 5,
    kCollectedTimestampFieldNumber = 3,
  };
  // map<string, string> status_map = 4;
  int status_map_size() const;
  private:
  int _internal_status_map_size() const;
  public:
  void clear_status_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_status_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_status_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      status_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_status_map();

  // string owner = 1;
  void clear_owner();
  const std::string& owner() const;
  void set_owner(const std::string& value);
  void set_owner(std::string&& value);
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  std::string* mutable_owner();
  std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // string repo = 2;
  void clear_repo();
  const std::string& repo() const;
  void set_repo(const std::string& value);
  void set_repo(std::string&& value);
  void set_repo(const char* value);
  void set_repo(const char* value, size_t size);
  std::string* mutable_repo();
  std::string* release_repo();
  void set_allocated_repo(std::string* repo);
  private:
  const std::string& _internal_repo() const;
  void _internal_set_repo(const std::string& value);
  std::string* _internal_mutable_repo();
  public:

  // .ecflow_client.ResponseStatus response_status = 5;
  bool has_response_status() const;
  private:
  bool _internal_has_response_status() const;
  public:
  void clear_response_status();
  const ::ecflow_client::ResponseStatus& response_status() const;
  ::ecflow_client::ResponseStatus* release_response_status();
  ::ecflow_client::ResponseStatus* mutable_response_status();
  void set_allocated_response_status(::ecflow_client::ResponseStatus* response_status);
  private:
  const ::ecflow_client::ResponseStatus& _internal_response_status() const;
  ::ecflow_client::ResponseStatus* _internal_mutable_response_status();
  public:

  // int64 collected_timestamp = 3;
  void clear_collected_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 collected_timestamp() const;
  void set_collected_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_collected_timestamp() const;
  void _internal_set_collected_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:ecflow_client.StatusRecordsResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      StatusRecordsResponse_StatusMapEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > status_map_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr repo_;
  ::ecflow_client::ResponseStatus* response_status_;
  ::PROTOBUF_NAMESPACE_ID::int64 collected_timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecflow_5fclient_2eproto;
};
// -------------------------------------------------------------------

class StatusResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecflow_client.StatusResponse) */ {
 public:
  StatusResponse();
  virtual ~StatusResponse();

  StatusResponse(const StatusResponse& from);
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusResponse* New() const final {
    return CreateMaybeMessage<StatusResponse>(nullptr);
  }

  StatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusResponse& from);
  void MergeFrom(const StatusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecflow_client.StatusResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ecflow_5fclient_2eproto);
    return ::descriptor_table_ecflow_5fclient_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerFieldNumber = 1,
    kRepoFieldNumber = 2,
    kStatusFieldNumber = 4,
    kResponseStatusFieldNumber = 5,
    kCollectedTimestampFieldNumber = 3,
  };
  // string owner = 1;
  void clear_owner();
  const std::string& owner() const;
  void set_owner(const std::string& value);
  void set_owner(std::string&& value);
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  std::string* mutable_owner();
  std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // string repo = 2;
  void clear_repo();
  const std::string& repo() const;
  void set_repo(const std::string& value);
  void set_repo(std::string&& value);
  void set_repo(const char* value);
  void set_repo(const char* value, size_t size);
  std::string* mutable_repo();
  std::string* release_repo();
  void set_allocated_repo(std::string* repo);
  private:
  const std::string& _internal_repo() const;
  void _internal_set_repo(const std::string& value);
  std::string* _internal_mutable_repo();
  public:

  // string status = 4;
  void clear_status();
  const std::string& status() const;
  void set_status(const std::string& value);
  void set_status(std::string&& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  std::string* mutable_status();
  std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .ecflow_client.ResponseStatus response_status = 5;
  bool has_response_status() const;
  private:
  bool _internal_has_response_status() const;
  public:
  void clear_response_status();
  const ::ecflow_client::ResponseStatus& response_status() const;
  ::ecflow_client::ResponseStatus* release_response_status();
  ::ecflow_client::ResponseStatus* mutable_response_status();
  void set_allocated_response_status(::ecflow_client::ResponseStatus* response_status);
  private:
  const ::ecflow_client::ResponseStatus& _internal_response_status() const;
  ::ecflow_client::ResponseStatus* _internal_mutable_response_status();
  public:

  // int64 collected_timestamp = 3;
  void clear_collected_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 collected_timestamp() const;
  void set_collected_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_collected_timestamp() const;
  void _internal_set_collected_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:ecflow_client.StatusResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr repo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::ecflow_client::ResponseStatus* response_status_;
  ::PROTOBUF_NAMESPACE_ID::int64 collected_timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecflow_5fclient_2eproto;
};
// -------------------------------------------------------------------

class NodeRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecflow_client.NodeRequest) */ {
 public:
  NodeRequest();
  virtual ~NodeRequest();

  NodeRequest(const NodeRequest& from);
  NodeRequest(NodeRequest&& from) noexcept
    : NodeRequest() {
    *this = ::std::move(from);
  }

  inline NodeRequest& operator=(const NodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRequest& operator=(NodeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeRequest*>(
               &_NodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NodeRequest& a, NodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeRequest* New() const final {
    return CreateMaybeMessage<NodeRequest>(nullptr);
  }

  NodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeRequest& from);
  void MergeFrom(const NodeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecflow_client.NodeRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ecflow_5fclient_2eproto);
    return ::descriptor_table_ecflow_5fclient_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerFieldNumber = 1,
    kRepoFieldNumber = 2,
    kHostFieldNumber = 3,
    kPortFieldNumber = 4,
    kPathFieldNumber = 5,
  };
  // string owner = 1;
  void clear_owner();
  const std::string& owner() const;
  void set_owner(const std::string& value);
  void set_owner(std::string&& value);
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  std::string* mutable_owner();
  std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // string repo = 2;
  void clear_repo();
  const std::string& repo() const;
  void set_repo(const std::string& value);
  void set_repo(std::string&& value);
  void set_repo(const char* value);
  void set_repo(const char* value, size_t size);
  std::string* mutable_repo();
  std::string* release_repo();
  void set_allocated_repo(std::string* repo);
  private:
  const std::string& _internal_repo() const;
  void _internal_set_repo(const std::string& value);
  std::string* _internal_mutable_repo();
  public:

  // string host = 3;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string port = 4;
  void clear_port();
  const std::string& port() const;
  void set_port(const std::string& value);
  void set_port(std::string&& value);
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  std::string* mutable_port();
  std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // string path = 5;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:ecflow_client.NodeRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr repo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecflow_5fclient_2eproto;
};
// -------------------------------------------------------------------

class NodeResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecflow_client.NodeResponse) */ {
 public:
  NodeResponse();
  virtual ~NodeResponse();

  NodeResponse(const NodeResponse& from);
  NodeResponse(NodeResponse&& from) noexcept
    : NodeResponse() {
    *this = ::std::move(from);
  }

  inline NodeResponse& operator=(const NodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeResponse& operator=(NodeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeResponse* internal_default_instance() {
    return reinterpret_cast<const NodeResponse*>(
               &_NodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NodeResponse& a, NodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeResponse* New() const final {
    return CreateMaybeMessage<NodeResponse>(nullptr);
  }

  NodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeResponse& from);
  void MergeFrom(const NodeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecflow_client.NodeResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ecflow_5fclient_2eproto);
    return ::descriptor_table_ecflow_5fclient_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerFieldNumber = 1,
    kRepoFieldNumber = 2,
    kPathFieldNumber = 3,
    kNodeFieldNumber = 4,
    kResponseStatusFieldNumber = 5,
  };
  // string owner = 1;
  void clear_owner();
  const std::string& owner() const;
  void set_owner(const std::string& value);
  void set_owner(std::string&& value);
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  std::string* mutable_owner();
  std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // string repo = 2;
  void clear_repo();
  const std::string& repo() const;
  void set_repo(const std::string& value);
  void set_repo(std::string&& value);
  void set_repo(const char* value);
  void set_repo(const char* value, size_t size);
  std::string* mutable_repo();
  std::string* release_repo();
  void set_allocated_repo(std::string* repo);
  private:
  const std::string& _internal_repo() const;
  void _internal_set_repo(const std::string& value);
  std::string* _internal_mutable_repo();
  public:

  // string path = 3;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string node = 4;
  void clear_node();
  const std::string& node() const;
  void set_node(const std::string& value);
  void set_node(std::string&& value);
  void set_node(const char* value);
  void set_node(const char* value, size_t size);
  std::string* mutable_node();
  std::string* release_node();
  void set_allocated_node(std::string* node);
  private:
  const std::string& _internal_node() const;
  void _internal_set_node(const std::string& value);
  std::string* _internal_mutable_node();
  public:

  // .ecflow_client.ResponseStatus response_status = 5;
  bool has_response_status() const;
  private:
  bool _internal_has_response_status() const;
  public:
  void clear_response_status();
  const ::ecflow_client::ResponseStatus& response_status() const;
  ::ecflow_client::ResponseStatus* release_response_status();
  ::ecflow_client::ResponseStatus* mutable_response_status();
  void set_allocated_response_status(::ecflow_client::ResponseStatus* response_status);
  private:
  const ::ecflow_client::ResponseStatus& _internal_response_status() const;
  ::ecflow_client::ResponseStatus* _internal_mutable_response_status();
  public:

  // @@protoc_insertion_point(class_scope:ecflow_client.NodeResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr repo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_;
  ::ecflow_client::ResponseStatus* response_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ecflow_5fclient_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ResponseStatus

// bool has_error = 1;
inline void ResponseStatus::clear_has_error() {
  has_error_ = false;
}
inline bool ResponseStatus::_internal_has_error() const {
  return has_error_;
}
inline bool ResponseStatus::has_error() const {
  // @@protoc_insertion_point(field_get:ecflow_client.ResponseStatus.has_error)
  return _internal_has_error();
}
inline void ResponseStatus::_internal_set_has_error(bool value) {
  
  has_error_ = value;
}
inline void ResponseStatus::set_has_error(bool value) {
  _internal_set_has_error(value);
  // @@protoc_insertion_point(field_set:ecflow_client.ResponseStatus.has_error)
}

// string error_string = 2;
inline void ResponseStatus::clear_error_string() {
  error_string_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ResponseStatus::error_string() const {
  // @@protoc_insertion_point(field_get:ecflow_client.ResponseStatus.error_string)
  return _internal_error_string();
}
inline void ResponseStatus::set_error_string(const std::string& value) {
  _internal_set_error_string(value);
  // @@protoc_insertion_point(field_set:ecflow_client.ResponseStatus.error_string)
}
inline std::string* ResponseStatus::mutable_error_string() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.ResponseStatus.error_string)
  return _internal_mutable_error_string();
}
inline const std::string& ResponseStatus::_internal_error_string() const {
  return error_string_.GetNoArena();
}
inline void ResponseStatus::_internal_set_error_string(const std::string& value) {
  
  error_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseStatus::set_error_string(std::string&& value) {
  
  error_string_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.ResponseStatus.error_string)
}
inline void ResponseStatus::set_error_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.ResponseStatus.error_string)
}
inline void ResponseStatus::set_error_string(const char* value, size_t size) {
  
  error_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.ResponseStatus.error_string)
}
inline std::string* ResponseStatus::_internal_mutable_error_string() {
  
  return error_string_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseStatus::release_error_string() {
  // @@protoc_insertion_point(field_release:ecflow_client.ResponseStatus.error_string)
  
  return error_string_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseStatus::set_allocated_error_string(std::string* error_string) {
  if (error_string != nullptr) {
    
  } else {
    
  }
  error_string_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_string);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.ResponseStatus.error_string)
}

// -------------------------------------------------------------------

// StatusRequest

// string owner = 1;
inline void StatusRequest::clear_owner() {
  owner_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StatusRequest::owner() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRequest.owner)
  return _internal_owner();
}
inline void StatusRequest::set_owner(const std::string& value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRequest.owner)
}
inline std::string* StatusRequest::mutable_owner() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRequest.owner)
  return _internal_mutable_owner();
}
inline const std::string& StatusRequest::_internal_owner() const {
  return owner_.GetNoArena();
}
inline void StatusRequest::_internal_set_owner(const std::string& value) {
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StatusRequest::set_owner(std::string&& value) {
  
  owner_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRequest.owner)
}
inline void StatusRequest::set_owner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRequest.owner)
}
inline void StatusRequest::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRequest.owner)
}
inline std::string* StatusRequest::_internal_mutable_owner() {
  
  return owner_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StatusRequest::release_owner() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRequest.owner)
  
  return owner_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRequest::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRequest.owner)
}

// string repo = 2;
inline void StatusRequest::clear_repo() {
  repo_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StatusRequest::repo() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRequest.repo)
  return _internal_repo();
}
inline void StatusRequest::set_repo(const std::string& value) {
  _internal_set_repo(value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRequest.repo)
}
inline std::string* StatusRequest::mutable_repo() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRequest.repo)
  return _internal_mutable_repo();
}
inline const std::string& StatusRequest::_internal_repo() const {
  return repo_.GetNoArena();
}
inline void StatusRequest::_internal_set_repo(const std::string& value) {
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StatusRequest::set_repo(std::string&& value) {
  
  repo_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRequest.repo)
}
inline void StatusRequest::set_repo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRequest.repo)
}
inline void StatusRequest::set_repo(const char* value, size_t size) {
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRequest.repo)
}
inline std::string* StatusRequest::_internal_mutable_repo() {
  
  return repo_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StatusRequest::release_repo() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRequest.repo)
  
  return repo_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRequest::set_allocated_repo(std::string* repo) {
  if (repo != nullptr) {
    
  } else {
    
  }
  repo_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), repo);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRequest.repo)
}

// string host = 3;
inline void StatusRequest::clear_host() {
  host_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StatusRequest::host() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRequest.host)
  return _internal_host();
}
inline void StatusRequest::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRequest.host)
}
inline std::string* StatusRequest::mutable_host() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRequest.host)
  return _internal_mutable_host();
}
inline const std::string& StatusRequest::_internal_host() const {
  return host_.GetNoArena();
}
inline void StatusRequest::_internal_set_host(const std::string& value) {
  
  host_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StatusRequest::set_host(std::string&& value) {
  
  host_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRequest.host)
}
inline void StatusRequest::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRequest.host)
}
inline void StatusRequest::set_host(const char* value, size_t size) {
  
  host_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRequest.host)
}
inline std::string* StatusRequest::_internal_mutable_host() {
  
  return host_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StatusRequest::release_host() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRequest.host)
  
  return host_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRequest::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRequest.host)
}

// string port = 4;
inline void StatusRequest::clear_port() {
  port_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StatusRequest::port() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRequest.port)
  return _internal_port();
}
inline void StatusRequest::set_port(const std::string& value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRequest.port)
}
inline std::string* StatusRequest::mutable_port() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRequest.port)
  return _internal_mutable_port();
}
inline const std::string& StatusRequest::_internal_port() const {
  return port_.GetNoArena();
}
inline void StatusRequest::_internal_set_port(const std::string& value) {
  
  port_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StatusRequest::set_port(std::string&& value) {
  
  port_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRequest.port)
}
inline void StatusRequest::set_port(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  port_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRequest.port)
}
inline void StatusRequest::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRequest.port)
}
inline std::string* StatusRequest::_internal_mutable_port() {
  
  return port_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StatusRequest::release_port() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRequest.port)
  
  return port_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRequest::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRequest.port)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StatusRecordsResponse

// string owner = 1;
inline void StatusRecordsResponse::clear_owner() {
  owner_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StatusRecordsResponse::owner() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRecordsResponse.owner)
  return _internal_owner();
}
inline void StatusRecordsResponse::set_owner(const std::string& value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRecordsResponse.owner)
}
inline std::string* StatusRecordsResponse::mutable_owner() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRecordsResponse.owner)
  return _internal_mutable_owner();
}
inline const std::string& StatusRecordsResponse::_internal_owner() const {
  return owner_.GetNoArena();
}
inline void StatusRecordsResponse::_internal_set_owner(const std::string& value) {
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StatusRecordsResponse::set_owner(std::string&& value) {
  
  owner_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRecordsResponse.owner)
}
inline void StatusRecordsResponse::set_owner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRecordsResponse.owner)
}
inline void StatusRecordsResponse::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRecordsResponse.owner)
}
inline std::string* StatusRecordsResponse::_internal_mutable_owner() {
  
  return owner_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StatusRecordsResponse::release_owner() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRecordsResponse.owner)
  
  return owner_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRecordsResponse::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRecordsResponse.owner)
}

// string repo = 2;
inline void StatusRecordsResponse::clear_repo() {
  repo_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StatusRecordsResponse::repo() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRecordsResponse.repo)
  return _internal_repo();
}
inline void StatusRecordsResponse::set_repo(const std::string& value) {
  _internal_set_repo(value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRecordsResponse.repo)
}
inline std::string* StatusRecordsResponse::mutable_repo() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRecordsResponse.repo)
  return _internal_mutable_repo();
}
inline const std::string& StatusRecordsResponse::_internal_repo() const {
  return repo_.GetNoArena();
}
inline void StatusRecordsResponse::_internal_set_repo(const std::string& value) {
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StatusRecordsResponse::set_repo(std::string&& value) {
  
  repo_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusRecordsResponse.repo)
}
inline void StatusRecordsResponse::set_repo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusRecordsResponse.repo)
}
inline void StatusRecordsResponse::set_repo(const char* value, size_t size) {
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusRecordsResponse.repo)
}
inline std::string* StatusRecordsResponse::_internal_mutable_repo() {
  
  return repo_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StatusRecordsResponse::release_repo() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRecordsResponse.repo)
  
  return repo_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRecordsResponse::set_allocated_repo(std::string* repo) {
  if (repo != nullptr) {
    
  } else {
    
  }
  repo_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), repo);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRecordsResponse.repo)
}

// int64 collected_timestamp = 3;
inline void StatusRecordsResponse::clear_collected_timestamp() {
  collected_timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatusRecordsResponse::_internal_collected_timestamp() const {
  return collected_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatusRecordsResponse::collected_timestamp() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRecordsResponse.collected_timestamp)
  return _internal_collected_timestamp();
}
inline void StatusRecordsResponse::_internal_set_collected_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  collected_timestamp_ = value;
}
inline void StatusRecordsResponse::set_collected_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_collected_timestamp(value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusRecordsResponse.collected_timestamp)
}

// map<string, string> status_map = 4;
inline int StatusRecordsResponse::_internal_status_map_size() const {
  return status_map_.size();
}
inline int StatusRecordsResponse::status_map_size() const {
  return _internal_status_map_size();
}
inline void StatusRecordsResponse::clear_status_map() {
  status_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StatusRecordsResponse::_internal_status_map() const {
  return status_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StatusRecordsResponse::status_map() const {
  // @@protoc_insertion_point(field_map:ecflow_client.StatusRecordsResponse.status_map)
  return _internal_status_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StatusRecordsResponse::_internal_mutable_status_map() {
  return status_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StatusRecordsResponse::mutable_status_map() {
  // @@protoc_insertion_point(field_mutable_map:ecflow_client.StatusRecordsResponse.status_map)
  return _internal_mutable_status_map();
}

// .ecflow_client.ResponseStatus response_status = 5;
inline bool StatusRecordsResponse::_internal_has_response_status() const {
  return this != internal_default_instance() && response_status_ != nullptr;
}
inline bool StatusRecordsResponse::has_response_status() const {
  return _internal_has_response_status();
}
inline void StatusRecordsResponse::clear_response_status() {
  if (GetArenaNoVirtual() == nullptr && response_status_ != nullptr) {
    delete response_status_;
  }
  response_status_ = nullptr;
}
inline const ::ecflow_client::ResponseStatus& StatusRecordsResponse::_internal_response_status() const {
  const ::ecflow_client::ResponseStatus* p = response_status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ecflow_client::ResponseStatus*>(
      &::ecflow_client::_ResponseStatus_default_instance_);
}
inline const ::ecflow_client::ResponseStatus& StatusRecordsResponse::response_status() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusRecordsResponse.response_status)
  return _internal_response_status();
}
inline ::ecflow_client::ResponseStatus* StatusRecordsResponse::release_response_status() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusRecordsResponse.response_status)
  
  ::ecflow_client::ResponseStatus* temp = response_status_;
  response_status_ = nullptr;
  return temp;
}
inline ::ecflow_client::ResponseStatus* StatusRecordsResponse::_internal_mutable_response_status() {
  
  if (response_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ecflow_client::ResponseStatus>(GetArenaNoVirtual());
    response_status_ = p;
  }
  return response_status_;
}
inline ::ecflow_client::ResponseStatus* StatusRecordsResponse::mutable_response_status() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusRecordsResponse.response_status)
  return _internal_mutable_response_status();
}
inline void StatusRecordsResponse::set_allocated_response_status(::ecflow_client::ResponseStatus* response_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete response_status_;
  }
  if (response_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_status, submessage_arena);
    }
    
  } else {
    
  }
  response_status_ = response_status;
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusRecordsResponse.response_status)
}

// -------------------------------------------------------------------

// StatusResponse

// string owner = 1;
inline void StatusResponse::clear_owner() {
  owner_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StatusResponse::owner() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.owner)
  return _internal_owner();
}
inline void StatusResponse::set_owner(const std::string& value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusResponse.owner)
}
inline std::string* StatusResponse::mutable_owner() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusResponse.owner)
  return _internal_mutable_owner();
}
inline const std::string& StatusResponse::_internal_owner() const {
  return owner_.GetNoArena();
}
inline void StatusResponse::_internal_set_owner(const std::string& value) {
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StatusResponse::set_owner(std::string&& value) {
  
  owner_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusResponse.owner)
}
inline void StatusResponse::set_owner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusResponse.owner)
}
inline void StatusResponse::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusResponse.owner)
}
inline std::string* StatusResponse::_internal_mutable_owner() {
  
  return owner_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StatusResponse::release_owner() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusResponse.owner)
  
  return owner_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusResponse.owner)
}

// string repo = 2;
inline void StatusResponse::clear_repo() {
  repo_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StatusResponse::repo() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.repo)
  return _internal_repo();
}
inline void StatusResponse::set_repo(const std::string& value) {
  _internal_set_repo(value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusResponse.repo)
}
inline std::string* StatusResponse::mutable_repo() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusResponse.repo)
  return _internal_mutable_repo();
}
inline const std::string& StatusResponse::_internal_repo() const {
  return repo_.GetNoArena();
}
inline void StatusResponse::_internal_set_repo(const std::string& value) {
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StatusResponse::set_repo(std::string&& value) {
  
  repo_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusResponse.repo)
}
inline void StatusResponse::set_repo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusResponse.repo)
}
inline void StatusResponse::set_repo(const char* value, size_t size) {
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusResponse.repo)
}
inline std::string* StatusResponse::_internal_mutable_repo() {
  
  return repo_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StatusResponse::release_repo() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusResponse.repo)
  
  return repo_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_repo(std::string* repo) {
  if (repo != nullptr) {
    
  } else {
    
  }
  repo_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), repo);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusResponse.repo)
}

// int64 collected_timestamp = 3;
inline void StatusResponse::clear_collected_timestamp() {
  collected_timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatusResponse::_internal_collected_timestamp() const {
  return collected_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatusResponse::collected_timestamp() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.collected_timestamp)
  return _internal_collected_timestamp();
}
inline void StatusResponse::_internal_set_collected_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  collected_timestamp_ = value;
}
inline void StatusResponse::set_collected_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_collected_timestamp(value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusResponse.collected_timestamp)
}

// string status = 4;
inline void StatusResponse::clear_status() {
  status_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StatusResponse::status() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.status)
  return _internal_status();
}
inline void StatusResponse::set_status(const std::string& value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ecflow_client.StatusResponse.status)
}
inline std::string* StatusResponse::mutable_status() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusResponse.status)
  return _internal_mutable_status();
}
inline const std::string& StatusResponse::_internal_status() const {
  return status_.GetNoArena();
}
inline void StatusResponse::_internal_set_status(const std::string& value) {
  
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StatusResponse::set_status(std::string&& value) {
  
  status_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.StatusResponse.status)
}
inline void StatusResponse::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.StatusResponse.status)
}
inline void StatusResponse::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.StatusResponse.status)
}
inline std::string* StatusResponse::_internal_mutable_status() {
  
  return status_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StatusResponse::release_status() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusResponse.status)
  
  return status_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusResponse.status)
}

// .ecflow_client.ResponseStatus response_status = 5;
inline bool StatusResponse::_internal_has_response_status() const {
  return this != internal_default_instance() && response_status_ != nullptr;
}
inline bool StatusResponse::has_response_status() const {
  return _internal_has_response_status();
}
inline void StatusResponse::clear_response_status() {
  if (GetArenaNoVirtual() == nullptr && response_status_ != nullptr) {
    delete response_status_;
  }
  response_status_ = nullptr;
}
inline const ::ecflow_client::ResponseStatus& StatusResponse::_internal_response_status() const {
  const ::ecflow_client::ResponseStatus* p = response_status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ecflow_client::ResponseStatus*>(
      &::ecflow_client::_ResponseStatus_default_instance_);
}
inline const ::ecflow_client::ResponseStatus& StatusResponse::response_status() const {
  // @@protoc_insertion_point(field_get:ecflow_client.StatusResponse.response_status)
  return _internal_response_status();
}
inline ::ecflow_client::ResponseStatus* StatusResponse::release_response_status() {
  // @@protoc_insertion_point(field_release:ecflow_client.StatusResponse.response_status)
  
  ::ecflow_client::ResponseStatus* temp = response_status_;
  response_status_ = nullptr;
  return temp;
}
inline ::ecflow_client::ResponseStatus* StatusResponse::_internal_mutable_response_status() {
  
  if (response_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ecflow_client::ResponseStatus>(GetArenaNoVirtual());
    response_status_ = p;
  }
  return response_status_;
}
inline ::ecflow_client::ResponseStatus* StatusResponse::mutable_response_status() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.StatusResponse.response_status)
  return _internal_mutable_response_status();
}
inline void StatusResponse::set_allocated_response_status(::ecflow_client::ResponseStatus* response_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete response_status_;
  }
  if (response_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_status, submessage_arena);
    }
    
  } else {
    
  }
  response_status_ = response_status;
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.StatusResponse.response_status)
}

// -------------------------------------------------------------------

// NodeRequest

// string owner = 1;
inline void NodeRequest::clear_owner() {
  owner_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NodeRequest::owner() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeRequest.owner)
  return _internal_owner();
}
inline void NodeRequest::set_owner(const std::string& value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeRequest.owner)
}
inline std::string* NodeRequest::mutable_owner() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeRequest.owner)
  return _internal_mutable_owner();
}
inline const std::string& NodeRequest::_internal_owner() const {
  return owner_.GetNoArena();
}
inline void NodeRequest::_internal_set_owner(const std::string& value) {
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NodeRequest::set_owner(std::string&& value) {
  
  owner_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeRequest.owner)
}
inline void NodeRequest::set_owner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeRequest.owner)
}
inline void NodeRequest::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeRequest.owner)
}
inline std::string* NodeRequest::_internal_mutable_owner() {
  
  return owner_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NodeRequest::release_owner() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeRequest.owner)
  
  return owner_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NodeRequest::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeRequest.owner)
}

// string repo = 2;
inline void NodeRequest::clear_repo() {
  repo_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NodeRequest::repo() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeRequest.repo)
  return _internal_repo();
}
inline void NodeRequest::set_repo(const std::string& value) {
  _internal_set_repo(value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeRequest.repo)
}
inline std::string* NodeRequest::mutable_repo() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeRequest.repo)
  return _internal_mutable_repo();
}
inline const std::string& NodeRequest::_internal_repo() const {
  return repo_.GetNoArena();
}
inline void NodeRequest::_internal_set_repo(const std::string& value) {
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NodeRequest::set_repo(std::string&& value) {
  
  repo_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeRequest.repo)
}
inline void NodeRequest::set_repo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeRequest.repo)
}
inline void NodeRequest::set_repo(const char* value, size_t size) {
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeRequest.repo)
}
inline std::string* NodeRequest::_internal_mutable_repo() {
  
  return repo_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NodeRequest::release_repo() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeRequest.repo)
  
  return repo_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NodeRequest::set_allocated_repo(std::string* repo) {
  if (repo != nullptr) {
    
  } else {
    
  }
  repo_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), repo);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeRequest.repo)
}

// string host = 3;
inline void NodeRequest::clear_host() {
  host_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NodeRequest::host() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeRequest.host)
  return _internal_host();
}
inline void NodeRequest::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeRequest.host)
}
inline std::string* NodeRequest::mutable_host() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeRequest.host)
  return _internal_mutable_host();
}
inline const std::string& NodeRequest::_internal_host() const {
  return host_.GetNoArena();
}
inline void NodeRequest::_internal_set_host(const std::string& value) {
  
  host_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NodeRequest::set_host(std::string&& value) {
  
  host_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeRequest.host)
}
inline void NodeRequest::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeRequest.host)
}
inline void NodeRequest::set_host(const char* value, size_t size) {
  
  host_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeRequest.host)
}
inline std::string* NodeRequest::_internal_mutable_host() {
  
  return host_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NodeRequest::release_host() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeRequest.host)
  
  return host_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NodeRequest::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeRequest.host)
}

// string port = 4;
inline void NodeRequest::clear_port() {
  port_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NodeRequest::port() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeRequest.port)
  return _internal_port();
}
inline void NodeRequest::set_port(const std::string& value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeRequest.port)
}
inline std::string* NodeRequest::mutable_port() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeRequest.port)
  return _internal_mutable_port();
}
inline const std::string& NodeRequest::_internal_port() const {
  return port_.GetNoArena();
}
inline void NodeRequest::_internal_set_port(const std::string& value) {
  
  port_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NodeRequest::set_port(std::string&& value) {
  
  port_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeRequest.port)
}
inline void NodeRequest::set_port(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  port_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeRequest.port)
}
inline void NodeRequest::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeRequest.port)
}
inline std::string* NodeRequest::_internal_mutable_port() {
  
  return port_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NodeRequest::release_port() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeRequest.port)
  
  return port_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NodeRequest::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeRequest.port)
}

// string path = 5;
inline void NodeRequest::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NodeRequest::path() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeRequest.path)
  return _internal_path();
}
inline void NodeRequest::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeRequest.path)
}
inline std::string* NodeRequest::mutable_path() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeRequest.path)
  return _internal_mutable_path();
}
inline const std::string& NodeRequest::_internal_path() const {
  return path_.GetNoArena();
}
inline void NodeRequest::_internal_set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NodeRequest::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeRequest.path)
}
inline void NodeRequest::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeRequest.path)
}
inline void NodeRequest::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeRequest.path)
}
inline std::string* NodeRequest::_internal_mutable_path() {
  
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NodeRequest::release_path() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeRequest.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NodeRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeRequest.path)
}

// -------------------------------------------------------------------

// NodeResponse

// string owner = 1;
inline void NodeResponse::clear_owner() {
  owner_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NodeResponse::owner() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeResponse.owner)
  return _internal_owner();
}
inline void NodeResponse::set_owner(const std::string& value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeResponse.owner)
}
inline std::string* NodeResponse::mutable_owner() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeResponse.owner)
  return _internal_mutable_owner();
}
inline const std::string& NodeResponse::_internal_owner() const {
  return owner_.GetNoArena();
}
inline void NodeResponse::_internal_set_owner(const std::string& value) {
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NodeResponse::set_owner(std::string&& value) {
  
  owner_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeResponse.owner)
}
inline void NodeResponse::set_owner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeResponse.owner)
}
inline void NodeResponse::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeResponse.owner)
}
inline std::string* NodeResponse::_internal_mutable_owner() {
  
  return owner_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NodeResponse::release_owner() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeResponse.owner)
  
  return owner_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NodeResponse::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeResponse.owner)
}

// string repo = 2;
inline void NodeResponse::clear_repo() {
  repo_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NodeResponse::repo() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeResponse.repo)
  return _internal_repo();
}
inline void NodeResponse::set_repo(const std::string& value) {
  _internal_set_repo(value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeResponse.repo)
}
inline std::string* NodeResponse::mutable_repo() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeResponse.repo)
  return _internal_mutable_repo();
}
inline const std::string& NodeResponse::_internal_repo() const {
  return repo_.GetNoArena();
}
inline void NodeResponse::_internal_set_repo(const std::string& value) {
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NodeResponse::set_repo(std::string&& value) {
  
  repo_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeResponse.repo)
}
inline void NodeResponse::set_repo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeResponse.repo)
}
inline void NodeResponse::set_repo(const char* value, size_t size) {
  
  repo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeResponse.repo)
}
inline std::string* NodeResponse::_internal_mutable_repo() {
  
  return repo_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NodeResponse::release_repo() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeResponse.repo)
  
  return repo_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NodeResponse::set_allocated_repo(std::string* repo) {
  if (repo != nullptr) {
    
  } else {
    
  }
  repo_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), repo);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeResponse.repo)
}

// string path = 3;
inline void NodeResponse::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NodeResponse::path() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeResponse.path)
  return _internal_path();
}
inline void NodeResponse::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeResponse.path)
}
inline std::string* NodeResponse::mutable_path() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeResponse.path)
  return _internal_mutable_path();
}
inline const std::string& NodeResponse::_internal_path() const {
  return path_.GetNoArena();
}
inline void NodeResponse::_internal_set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NodeResponse::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeResponse.path)
}
inline void NodeResponse::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeResponse.path)
}
inline void NodeResponse::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeResponse.path)
}
inline std::string* NodeResponse::_internal_mutable_path() {
  
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NodeResponse::release_path() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeResponse.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NodeResponse::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeResponse.path)
}

// string node = 4;
inline void NodeResponse::clear_node() {
  node_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NodeResponse::node() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeResponse.node)
  return _internal_node();
}
inline void NodeResponse::set_node(const std::string& value) {
  _internal_set_node(value);
  // @@protoc_insertion_point(field_set:ecflow_client.NodeResponse.node)
}
inline std::string* NodeResponse::mutable_node() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeResponse.node)
  return _internal_mutable_node();
}
inline const std::string& NodeResponse::_internal_node() const {
  return node_.GetNoArena();
}
inline void NodeResponse::_internal_set_node(const std::string& value) {
  
  node_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NodeResponse::set_node(std::string&& value) {
  
  node_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecflow_client.NodeResponse.node)
}
inline void NodeResponse::set_node(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  node_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecflow_client.NodeResponse.node)
}
inline void NodeResponse::set_node(const char* value, size_t size) {
  
  node_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecflow_client.NodeResponse.node)
}
inline std::string* NodeResponse::_internal_mutable_node() {
  
  return node_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NodeResponse::release_node() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeResponse.node)
  
  return node_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NodeResponse::set_allocated_node(std::string* node) {
  if (node != nullptr) {
    
  } else {
    
  }
  node_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node);
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeResponse.node)
}

// .ecflow_client.ResponseStatus response_status = 5;
inline bool NodeResponse::_internal_has_response_status() const {
  return this != internal_default_instance() && response_status_ != nullptr;
}
inline bool NodeResponse::has_response_status() const {
  return _internal_has_response_status();
}
inline void NodeResponse::clear_response_status() {
  if (GetArenaNoVirtual() == nullptr && response_status_ != nullptr) {
    delete response_status_;
  }
  response_status_ = nullptr;
}
inline const ::ecflow_client::ResponseStatus& NodeResponse::_internal_response_status() const {
  const ::ecflow_client::ResponseStatus* p = response_status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ecflow_client::ResponseStatus*>(
      &::ecflow_client::_ResponseStatus_default_instance_);
}
inline const ::ecflow_client::ResponseStatus& NodeResponse::response_status() const {
  // @@protoc_insertion_point(field_get:ecflow_client.NodeResponse.response_status)
  return _internal_response_status();
}
inline ::ecflow_client::ResponseStatus* NodeResponse::release_response_status() {
  // @@protoc_insertion_point(field_release:ecflow_client.NodeResponse.response_status)
  
  ::ecflow_client::ResponseStatus* temp = response_status_;
  response_status_ = nullptr;
  return temp;
}
inline ::ecflow_client::ResponseStatus* NodeResponse::_internal_mutable_response_status() {
  
  if (response_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ecflow_client::ResponseStatus>(GetArenaNoVirtual());
    response_status_ = p;
  }
  return response_status_;
}
inline ::ecflow_client::ResponseStatus* NodeResponse::mutable_response_status() {
  // @@protoc_insertion_point(field_mutable:ecflow_client.NodeResponse.response_status)
  return _internal_mutable_response_status();
}
inline void NodeResponse::set_allocated_response_status(::ecflow_client::ResponseStatus* response_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete response_status_;
  }
  if (response_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_status, submessage_arena);
    }
    
  } else {
    
  }
  response_status_ = response_status;
  // @@protoc_insertion_point(field_set_allocated:ecflow_client.NodeResponse.response_status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ecflow_client

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ecflow_5fclient_2eproto
